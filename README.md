# Python정리
## 1.변수와 데이터 형식
* print
1. "" 안에 있는건 문자열
2. print("%d %d" % (100,200)) %d는 정수,중간의 %는 왼쪽과 오른쪽 구별(,가 아니라 %다)
* type :변수 종류 확인
* ",' 그대로 출력하려면 앞에 \써주기
* input() :값 입력 받기 ,문자열이다
## 2.연산자
* 산술연산자
1. // :나누기(몫)
2. ** :제곱
* 문자열 <-> 숫자
1. int() :문자열->정수
2. float() :문자열->실수
3. str() :숫자->문자열
* 논리연산자 :and,or,not
* 파이썬에서 숫자 0만 거짓이고 그 외의 수는 참이다
## 3.조건문
* if문
```
if a <100:
    print()
```
* else if문
```
if a<100:
    print()
else:
    print()
```
else if는 elif로 줄여쓸 수 있다   
if 항목 in list :리스트 안에 항목이 있으면 true
## 4.반복문
* for문
```
for i in range(시작,끝+1,증가값):
    print()
```
ex) range(0,3,1)->0,1,2 3번 반복/증가값을 생략하면 자동으로 1씩 증가한다
* while문
```
while 조건(참일때만 실행):
    print()
```
* break :만나면 반복문 탈출
* continue :남은 코드 건너뛰고 반복문으로 다시 돌아감

## 5.리스트,튜플,딕셔너리
### 1.리스트
* 리스트 :c나 자바의 배열처럼 데이터를 하나로 묶고 인덱스를 통해 접근 , 배열과 달리 서로 다른 데이터 형식을 저장 할 수 있다.(인덱스는 0부터 시작)       
```리스트이름=[값1 ,값2, 값3 ...]``` 초기화 할때는 빈 [] 사용
* 리스트이름.append(값) :리스트에 값 추가,리스트 추가도 가능
* 인덱스 음수로 접근하면 제일 뒤에서부터 -1로 접근한다
* 리스트 범위 지정   
```리스트이름[시작:끝+1]```
ex) aa[2:4]->index 2,3에 접근/콜론 앞 뒤 생략 가능(끝까지)
* 리스트 연산
1. 더하기
a=[1,2,3] b=[4,5,6]
a+b=[1,2,3,4,5,6]
2. 곱하기
a*2=[1,2,1,2]
* 리스트 삭제 :del(리스트[인덱스])
* 기타 리스트 함수
1. sort()
2. reverse()
3. index(값):지정한 값의 인덱스 반환
4. insert(인덱스,값):지정한 위치에 값을 삽입
5. remove(값):지정한 값을 삭제,여러개일 경우 첫번째만 삭제한다
6. extend():리스트+리스트 ,더하기 연산과 같다
7. count(값):값의 개수를 센다
8. len(리스트):리스트 항목의 개수를 센다
* map(함수명,리스트이름) :리스트 값을 하나하나 함수에 대입
```list1=['2020,'2','10'] map(int,list1) str->int```

### 2.튜플
* 리스트와 튜플의 차이점? 
튜플은 ()로 생성한다, 값을 수정할 수 없어 읽기 전용 자료 저장할때 사용
* 하나의 항목을 가진 튜플을 만들때는 ,를 꼭 붙여야 한다
* del(튜플):튜플 삭제
* 튜플도 인덱스를 사용해 접근
* 튜플[시작:끝+1]를 통해 범위에 접근
* 더하기,곱하기 연산 가능
* 리스트와 튜플 변환
1. list(튜플):튜플->리스트
2. tuple(리스트):리스트-튜플

### 3.딕셔너리
* 딕셔너리:두개의 쌍이 하나로 묶이는 사전형 구조,여러개의 정보를 하나의 변수로 표현할때 유용 ,순서 의미x 
```딕셔너리={키1:값1,키2:값2 ...}```
* 딕셔너리 추가
```딕셔너리[키]=값```   
이미 있는 키를 사용하면 기존의 값이 변경된다
* 딕셔너리 삭제
```del(딕셔너리[키])```
* 키를 이용해 값에 접근
```딕셔너리.get(키)/딕셔너리[키]```get은 없는 키를 호출할때 아무것도 반환x 
* 딕셔너리.keys() :딕셔너리의 모든 키 반환
* 딕셔너리.values() :딕셔너리의 모든 값 반환
* 딕셔너리.items() :튜플 형태로 반환
* 딕셔너리 안에 키가 있는지 확인
```키 in 딕셔너리```

## 6.문자열
* 문자열도 인덱스로 접근이 가능
* +로 연결 ,*로 반복 가능
* len():문자열 길이 출력
* 여러가지 문자열 함수
1. upper/lower 대소문자 변환
2. count(문자열):문자열이 몇개 있는지   
3. find(문자열):문자열이 몇번째 위치하는지/문자열 없으면 -1 리턴   
4. index(문자열):문자열이 몇번재 위치하는지/문자열 없으면 오류   
5. strip():공백,특정문자 제거(문자열 중간의 공백이나 문자는 제거되지 않는다)   
6. replace(old,new):문자열 대체   
7. split():문자열을 공백이나 다른 문자로 분리해서 리스트로 반환   
8. join():문자열 합침
``` ex) ss='%' ss.join('파이썬')->파%이%썬```   
9. isdigit,isalpha,isalnum,islower...

## 7.함수
* 함수:호출되었을때만 실행되는 코드 블럭 ,코드를 재사용 할 수 있게 해줌
```
def func(a,b):
    result=a+b
    return result

sum=func(1,2)//sum에 result 반환값 대입
```
* 지역변수 :특정 범위에서만 사용되는 변수 ex)함수 안
* 전역변수: 프로그램 전체에서 사용되는 변수
* 가변 매개변수 :매개변수 앞에 * 붙이기->튜플 형식으로 넘어온다/ **는 딕셔너리
* 모듈 :함수의 집합
```a.py 프로그램과 b.py 프로그램에서 func1() 함수를 사용할때 func.py에 func1()을 정의해 놓고 a.py 와 b.py에 import해서 사용```
* func.py
```
def func1():
    print("func1 호출")

def func2():
    print("func2 호출")
```
* a.py
```
import func
func.func1()
func.func2()
```
모듈 이름을 생략하고 싶다면 
```from func import func1,func2 로 수정```
* 모듈 종류: 표준 모듈, 사용자 정의 모듈, 서드 파티 모듈(파이썬이 아닌 다른 회사나 기관에서 제공하는 모듈)

## 8.파일 입출력
* 파일 처리 단계   
```파일 열기->파일 읽기 및 쓰기->파일 닫기```
1. 파일 열기   
변수=open("파일이름","모드")    
```모드에는 r,w,r+,a등이 있다``` 한글이 깨지지 않으려면 encoding="utf-8"추가
2. 파일 닫기   
변수.close()
* 파일 입력
1. readline() :한 행씩 읽어오기
2. readlines() :한번에 읽어오기 ->각 행을 리스트 항목으로 저장해서 반환
3. read() :한 바이트씩 읽어오기
* 파일 open 오류 처리   
os.path.exists() :파일이 있는지 확인 (import
 os)

* 파일 출력
1. writelines() :한 행씩 쓰기
2. write() :한 바이트씩 쓰기

## 9.객체지향 
```
class 클래스이름:
    속성(필드)
    ...
    기능(메소드)
    ...
```
* self :클래스 자신을 가리킴, 메소드 안에서 필드에 접근하기 위해 사용
* 클래스:자동차 설계도   
 인스턴스:설계도를 바탕으로 제작한 실제 자동차
 ```
 myCar=Car() //인스턴스 생성
 myCar.color="red"
 myCar.speed=100 
 mycar.upSpeed(120)
 ```
 ```인스턴스이름.필드이름/인스턴스이름.메소드이름()으로 접근 가능```

* 생성자 :인스턴스를 생성하면 무조건 호출되는 메소드   
```
class 클래스이름:
    color=""
    speed=0
    def __init__(self): //기본 생성자(매개변수에 self만 있는 생성자)
        self.color="red"
        self.speed=0
```
* 매개변수가 있는 생성자
```def __init__(self,var1,var2) myCar=Car("red",30)```
* 인스턴스 변수와 클래스 변수
1. 인스턴스 변수 :인스턴스를 생성해야 사용할 수 있는 변수
2. 클래스 변수 :클래스 안에 공간이 할당된 변수 , 추가로 공간을 할당하지 않고 여러 인스턴스가 공유
```클래스이름.변수이름/인스턴스.변수이름```   
생성자에서 self를 붙이면 인스턴스 변수 클래스 이름 붙이면 클래스 변수
* 상속 :기존의 클래스가 가지고 있는 필드와 메소드를 그대로 물려받는 새로운 클래스를 만드는것   
상위 클래스 :슈퍼 클래스, 부모 클래스   
하위 클래스 :서브 클래스, 자식 클래스
```
class sub(super):
    서브 클래스 내용 
```
* 메소드 오버라이딩: 서브 클래스에서 슈퍼 클래스의 메소드를 재정의 하는 것

## 10.데이터베이스
* 데이터베이스: 대량의 데이터를 체계적으로 저장해 놓은 것 ,여러명의 사용자나 시스템이 공유할 수 있어야 한다
* DBMS:DataBase Management System
* 관계형 데이터베이스   
단점: 시스템 자원을 많이 차지해서 시스템이 느려진다
* 데이터베이스 모델링 :현실 세계에서 사용되는 데이터를 DBMS안에 어떻게 옮겨 놓을지 정하는 과정
1. 데이터 : 하나 하나의 단편적인 정보
2. 테이블 : 회원 데이터가 표 형태로 표현된 것
3. 데이터베이스: 테이블이 저장되는 저장소
4. DBMS :데이터베이스를 관리하는 시스템이나 소프트웨어 ex)SQLite
5. 열(컬럼,필드)/열 이름 :중복x
6. 행 :실질적인 데이터
7. 데이터형식 :열의 데이터 형식 ex)회원 이름 열은 문자 형식임
8. SQL :DBMS와 사용자가 소통하기 위한 언어
* 파이썬에서 SQLite 사용하기   
데이터 입력
1. 데이터베이스 연결
```
import sqlite3
con=sqlite3.connect("naverDB") 
//con(연결자) 디비이름이 있으면 디비에 연결되고 없으면 새로 생성된 후에 연결
```
2. 커서 생성  
커서(cursor):데이터베이스에 SQL문을 실행하거나 실행된 결과를 돌려받는 통로 1에서 연결한 연결자에 커서를 만들어야 한다
```cur=con.cursor()```
3. 테이블 생성(기존 테이블 있으면 생략)
```
cur.execute("CREATE TABLE userTable(id char(4),userName char(15),email char(15), birthYear int)")
```
4. 데이터 입력
```
cur.execute("INSERT INTO userTable VALUES('park','Park sehui' 'poa0909@naver.com',1999)")
```
5. 데이터 저장
```con.commit()```
6. 데이터베이스 닫기
```con.close()```

데이터 조회
1. 데이터베이스 연결
2. 커서 생성
3. 데이터 조회
```
cur.execute("SELECT * FROM userTable)
//WHERE 조건 사용 가능
```
4. 조회한 데이터 출력
```cur.fetchone() //결과를 한 행씩 추출```
5. 데이터베이스 닫기
